..........EE...........................s...............................s [ 72%]
s.............E.E...........                                             [100%]
=================================== ERRORS ====================================
_______________ ERROR at setup of test_pipeline_nonexistent_pdf _______________

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
>           os.rmdir(path)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:631: PermissionError

During handling of the above exception, another exception occurred:

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
ignore_errors = False, onerror = None

    def rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):
        """Recursively delete a directory tree.
    
        If dir_fd is not None, it should be a file descriptor open to a directory;
        path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
        If it is unavailable, using it will raise a NotImplementedError.
    
        If ignore_errors is set, errors are ignored; otherwise, if onexc or
        onerror is set, it is called to handle the error with arguments (func,
        path, exc_info) where func is platform and implementation dependent;
        path is the argument to that function that caused it to fail; and
        the value of exc_info describes the exception. For onexc it is the
        exception instance, and for onerror it is a tuple as returned by
        sys.exc_info().  If ignore_errors is false and both onexc and
        onerror are None, the exception is reraised.
    
        onerror is deprecated and only remains for backwards compatibility.
        If both onerror and onexc are set, onerror is ignored and onexc is used.
        """
    
        sys.audit("shutil.rmtree", path, dir_fd)
        if ignore_errors:
            def onexc(*args):
                pass
        elif onerror is None and onexc is None:
            def onexc(*args):
                raise
        elif onexc is None:
            if onerror is None:
                def onexc(*args):
                    raise
            else:
                # delegate to onerror
                def onexc(*args):
                    func, path, exc = args
                    if exc is None:
                        exc_info = None, None, None
                    else:
                        exc_info = type(exc), exc, exc.__traceback__
                    return onerror(func, path, exc_info)
    
        if _use_fd_functions:
            # While the unsafe rmtree works fine on bytes, the fd based does not.
            if isinstance(path, bytes):
                path = os.fsdecode(path)
            stack = [(os.lstat, dir_fd, path, None)]
            try:
                while stack:
                    _rmtree_safe_fd(stack, onexc)
            finally:
                # Close any file descriptors still on the stack.
                while stack:
                    func, fd, path, entry = stack.pop()
                    if func is not os.close:
                        continue
                    try:
                        os.close(fd)
                    except OSError as err:
                        onexc(os.close, path, err)
        else:
            if dir_fd is not None:
                raise NotImplementedError("dir_fd unavailable on this platform")
            try:
                st = os.lstat(path)
            except OSError as err:
                onexc(os.lstat, path, err)
                return
            try:
                if _rmtree_islink(st):
                    # symlinks to directories are forbidden, see bug #1669
                    raise OSError("Cannot call rmtree on a symbolic link")
            except OSError as err:
                onexc(os.path.islink, path, err)
                # can't continue even if onexc hook returns
                return
>           return _rmtree_unsafe(path, onexc)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\ProgramData\miniconda3\Lib\shutil.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
            os.rmdir(path)
        except FileNotFoundError:
            pass
        except OSError as err:
>           onexc(os.rmdir, path, err)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:635: PermissionError
___________________ ERROR at setup of test_pipeline_success ___________________

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
>           os.rmdir(path)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:631: PermissionError

During handling of the above exception, another exception occurred:

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
ignore_errors = False, onerror = None

    def rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):
        """Recursively delete a directory tree.
    
        If dir_fd is not None, it should be a file descriptor open to a directory;
        path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
        If it is unavailable, using it will raise a NotImplementedError.
    
        If ignore_errors is set, errors are ignored; otherwise, if onexc or
        onerror is set, it is called to handle the error with arguments (func,
        path, exc_info) where func is platform and implementation dependent;
        path is the argument to that function that caused it to fail; and
        the value of exc_info describes the exception. For onexc it is the
        exception instance, and for onerror it is a tuple as returned by
        sys.exc_info().  If ignore_errors is false and both onexc and
        onerror are None, the exception is reraised.
    
        onerror is deprecated and only remains for backwards compatibility.
        If both onerror and onexc are set, onerror is ignored and onexc is used.
        """
    
        sys.audit("shutil.rmtree", path, dir_fd)
        if ignore_errors:
            def onexc(*args):
                pass
        elif onerror is None and onexc is None:
            def onexc(*args):
                raise
        elif onexc is None:
            if onerror is None:
                def onexc(*args):
                    raise
            else:
                # delegate to onerror
                def onexc(*args):
                    func, path, exc = args
                    if exc is None:
                        exc_info = None, None, None
                    else:
                        exc_info = type(exc), exc, exc.__traceback__
                    return onerror(func, path, exc_info)
    
        if _use_fd_functions:
            # While the unsafe rmtree works fine on bytes, the fd based does not.
            if isinstance(path, bytes):
                path = os.fsdecode(path)
            stack = [(os.lstat, dir_fd, path, None)]
            try:
                while stack:
                    _rmtree_safe_fd(stack, onexc)
            finally:
                # Close any file descriptors still on the stack.
                while stack:
                    func, fd, path, entry = stack.pop()
                    if func is not os.close:
                        continue
                    try:
                        os.close(fd)
                    except OSError as err:
                        onexc(os.close, path, err)
        else:
            if dir_fd is not None:
                raise NotImplementedError("dir_fd unavailable on this platform")
            try:
                st = os.lstat(path)
            except OSError as err:
                onexc(os.lstat, path, err)
                return
            try:
                if _rmtree_islink(st):
                    # symlinks to directories are forbidden, see bug #1669
                    raise OSError("Cannot call rmtree on a symbolic link")
            except OSError as err:
                onexc(os.path.islink, path, err)
                # can't continue even if onexc hook returns
                return
>           return _rmtree_unsafe(path, onexc)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\ProgramData\miniconda3\Lib\shutil.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
            os.rmdir(path)
        except FileNotFoundError:
            pass
        except OSError as err:
>           onexc(os.rmdir, path, err)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:635: PermissionError
_________________ ERROR at setup of test_emit_site_risk_json __________________

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
>           os.rmdir(path)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:631: PermissionError

During handling of the above exception, another exception occurred:

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
ignore_errors = False, onerror = None

    def rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):
        """Recursively delete a directory tree.
    
        If dir_fd is not None, it should be a file descriptor open to a directory;
        path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
        If it is unavailable, using it will raise a NotImplementedError.
    
        If ignore_errors is set, errors are ignored; otherwise, if onexc or
        onerror is set, it is called to handle the error with arguments (func,
        path, exc_info) where func is platform and implementation dependent;
        path is the argument to that function that caused it to fail; and
        the value of exc_info describes the exception. For onexc it is the
        exception instance, and for onerror it is a tuple as returned by
        sys.exc_info().  If ignore_errors is false and both onexc and
        onerror are None, the exception is reraised.
    
        onerror is deprecated and only remains for backwards compatibility.
        If both onerror and onexc are set, onerror is ignored and onexc is used.
        """
    
        sys.audit("shutil.rmtree", path, dir_fd)
        if ignore_errors:
            def onexc(*args):
                pass
        elif onerror is None and onexc is None:
            def onexc(*args):
                raise
        elif onexc is None:
            if onerror is None:
                def onexc(*args):
                    raise
            else:
                # delegate to onerror
                def onexc(*args):
                    func, path, exc = args
                    if exc is None:
                        exc_info = None, None, None
                    else:
                        exc_info = type(exc), exc, exc.__traceback__
                    return onerror(func, path, exc_info)
    
        if _use_fd_functions:
            # While the unsafe rmtree works fine on bytes, the fd based does not.
            if isinstance(path, bytes):
                path = os.fsdecode(path)
            stack = [(os.lstat, dir_fd, path, None)]
            try:
                while stack:
                    _rmtree_safe_fd(stack, onexc)
            finally:
                # Close any file descriptors still on the stack.
                while stack:
                    func, fd, path, entry = stack.pop()
                    if func is not os.close:
                        continue
                    try:
                        os.close(fd)
                    except OSError as err:
                        onexc(os.close, path, err)
        else:
            if dir_fd is not None:
                raise NotImplementedError("dir_fd unavailable on this platform")
            try:
                st = os.lstat(path)
            except OSError as err:
                onexc(os.lstat, path, err)
                return
            try:
                if _rmtree_islink(st):
                    # symlinks to directories are forbidden, see bug #1669
                    raise OSError("Cannot call rmtree on a symbolic link")
            except OSError as err:
                onexc(os.path.islink, path, err)
                # can't continue even if onexc hook returns
                return
>           return _rmtree_unsafe(path, onexc)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\ProgramData\miniconda3\Lib\shutil.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
            os.rmdir(path)
        except FileNotFoundError:
            pass
        except OSError as err:
>           onexc(os.rmdir, path, err)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:635: PermissionError
_________________ ERROR at setup of test_load_validator_tiers _________________

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
>           os.rmdir(path)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:631: PermissionError

During handling of the above exception, another exception occurred:

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
ignore_errors = False, onerror = None

    def rmtree(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None):
        """Recursively delete a directory tree.
    
        If dir_fd is not None, it should be a file descriptor open to a directory;
        path will then be relative to that directory.
        dir_fd may not be implemented on your platform.
        If it is unavailable, using it will raise a NotImplementedError.
    
        If ignore_errors is set, errors are ignored; otherwise, if onexc or
        onerror is set, it is called to handle the error with arguments (func,
        path, exc_info) where func is platform and implementation dependent;
        path is the argument to that function that caused it to fail; and
        the value of exc_info describes the exception. For onexc it is the
        exception instance, and for onerror it is a tuple as returned by
        sys.exc_info().  If ignore_errors is false and both onexc and
        onerror are None, the exception is reraised.
    
        onerror is deprecated and only remains for backwards compatibility.
        If both onerror and onexc are set, onerror is ignored and onexc is used.
        """
    
        sys.audit("shutil.rmtree", path, dir_fd)
        if ignore_errors:
            def onexc(*args):
                pass
        elif onerror is None and onexc is None:
            def onexc(*args):
                raise
        elif onexc is None:
            if onerror is None:
                def onexc(*args):
                    raise
            else:
                # delegate to onerror
                def onexc(*args):
                    func, path, exc = args
                    if exc is None:
                        exc_info = None, None, None
                    else:
                        exc_info = type(exc), exc, exc.__traceback__
                    return onerror(func, path, exc_info)
    
        if _use_fd_functions:
            # While the unsafe rmtree works fine on bytes, the fd based does not.
            if isinstance(path, bytes):
                path = os.fsdecode(path)
            stack = [(os.lstat, dir_fd, path, None)]
            try:
                while stack:
                    _rmtree_safe_fd(stack, onexc)
            finally:
                # Close any file descriptors still on the stack.
                while stack:
                    func, fd, path, entry = stack.pop()
                    if func is not os.close:
                        continue
                    try:
                        os.close(fd)
                    except OSError as err:
                        onexc(os.close, path, err)
        else:
            if dir_fd is not None:
                raise NotImplementedError("dir_fd unavailable on this platform")
            try:
                st = os.lstat(path)
            except OSError as err:
                onexc(os.lstat, path, err)
                return
            try:
                if _rmtree_islink(st):
                    # symlinks to directories are forbidden, see bug #1669
                    raise OSError("Cannot call rmtree on a symbolic link")
            except OSError as err:
                onexc(os.path.islink, path, err)
                # can't continue even if onexc hook returns
                return
>           return _rmtree_unsafe(path, onexc)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\ProgramData\miniconda3\Lib\shutil.py:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'
onexc = functools.partial(<function on_rm_rf_error at 0x000002E4533BEF20>, start_path=WindowsPath('//?/C:/Code/bar-directory-recon/logs/pytest_basetemp_full_20250820_204659'))

    def _rmtree_unsafe(path, onexc):
        def onerror(err):
            if not isinstance(err, FileNotFoundError):
                onexc(os.scandir, err.filename, err)
        results = os.walk(path, topdown=False, onerror=onerror, followlinks=os._walk_symlinks_as_files)
        for dirpath, dirnames, filenames in results:
            for name in dirnames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.rmdir(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.rmdir, fullname, err)
            for name in filenames:
                fullname = os.path.join(dirpath, name)
                try:
                    os.unlink(fullname)
                except FileNotFoundError:
                    continue
                except OSError as err:
                    onexc(os.unlink, fullname, err)
        try:
            os.rmdir(path)
        except FileNotFoundError:
            pass
        except OSError as err:
>           onexc(os.rmdir, path, err)
E           PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: '\\\\?\\C:\\Code\\bar-directory-recon\\logs\\pytest_basetemp_full_20250820_204659'

C:\ProgramData\miniconda3\Lib\shutil.py:635: PermissionError
============================== warnings summary ===============================
universal_recon\tests\analytics\test_plugin_usage_diff.py:14
  C:\Code\bar-directory-recon\universal_recon\tests\analytics\test_plugin_usage_diff.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.analytics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.analytics

universal_recon\tests\analytics\test_risk_overlay_emitter.py:18
  C:\Code\bar-directory-recon\universal_recon\tests\analytics\test_risk_overlay_emitter.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.analytics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.analytics

test_data_hunter.py::test_discovery
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_data_hunter.py::test_discovery returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_imports
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_imports returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_basic_functionality
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_basic_functionality returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_config_validation
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_config_validation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_google_sheets.py::test_cli_arguments
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_google_sheets.py::test_cli_arguments returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_google_sheets.py::test_logs_directory
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_google_sheets.py::test_logs_directory returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_plugin_architecture.py::test_plugin_architecture
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_plugin_architecture.py::test_plugin_architecture returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_plugin_architecture_fixed.py::test_plugin_architecture
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_plugin_architecture_fixed.py::test_plugin_architecture returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_plugin_registry
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_plugin_registry returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_new_plugins
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_new_plugins returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_universal_automation
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_universal_automation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_lead_scoring
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_lead_scoring returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_google_sheets_utils
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_google_sheets_utils returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_file_structure
  C:\Code\bar-directory-recon\.venv-ci\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_file_structure returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
- generated xml file: C:\Code\bar-directory-recon\logs\nightly\junit_full_20250820_204659.xml -
=========================== short test summary info ===========================
ERROR src/tests/test_hallandale_pipeline.py::test_pipeline_nonexistent_pdf - ...
ERROR src/tests/test_hallandale_pipeline_success.py::test_pipeline_success - ...
ERROR universal_recon/tests/test_risk_overlay_emitter.py::test_emit_site_risk_json
ERROR universal_recon/tests/test_risk_overlay_emitter.py::test_load_validator_tiers
