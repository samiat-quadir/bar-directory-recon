..........EE..FF.......................s.........................F...F.s [ 72%]
s...FF........E.E...........                                             [100%]
=================================== ERRORS ====================================
_______________ ERROR at setup of test_pipeline_nonexistent_pdf _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x00000270F0C196C0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\_pytest\runner.py:246: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
.venv\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\runner.py:164: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv\Lib\site-packages\_pytest\runner.py:514: in setup
    col.setup()
.venv\Lib\site-packages\_pytest\python.py:1674: in setup
    self._request._fillfixtures()
.venv\Lib\site-packages\_pytest\fixtures.py:719: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:548: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:639: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv\Lib\site-packages\_pytest\fixtures.py:1127: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:1195: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:922: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:264: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:251: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
.venv\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
.venv\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/samqu/AppData/Local/Temp/pytest-of-samqu')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\samqu\\AppData\\Local\\Temp\\pytest-of-samqu'

.venv\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
___________________ ERROR at setup of test_pipeline_success ___________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x00000270A13AB6A0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\_pytest\runner.py:246: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
.venv\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\runner.py:164: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv\Lib\site-packages\_pytest\runner.py:514: in setup
    col.setup()
.venv\Lib\site-packages\_pytest\python.py:1674: in setup
    self._request._fillfixtures()
.venv\Lib\site-packages\_pytest\fixtures.py:719: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:548: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:639: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv\Lib\site-packages\_pytest\fixtures.py:1127: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:1195: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:922: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:264: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:251: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
.venv\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
.venv\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/samqu/AppData/Local/Temp/pytest-of-samqu')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\samqu\\AppData\\Local\\Temp\\pytest-of-samqu'

.venv\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_________________ ERROR at setup of test_emit_site_risk_json __________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x00000270A167E840>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\_pytest\runner.py:246: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
.venv\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\runner.py:164: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv\Lib\site-packages\_pytest\runner.py:514: in setup
    col.setup()
.venv\Lib\site-packages\_pytest\python.py:1674: in setup
    self._request._fillfixtures()
.venv\Lib\site-packages\_pytest\fixtures.py:719: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:548: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:639: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv\Lib\site-packages\_pytest\fixtures.py:1127: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:1195: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:922: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:264: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:251: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
.venv\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
.venv\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/samqu/AppData/Local/Temp/pytest-of-samqu')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\samqu\\AppData\\Local\\Temp\\pytest-of-samqu'

.venv\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_________________ ERROR at setup of test_load_validator_tiers _________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x00000270A163E200>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

.venv\Lib\site-packages\_pytest\runner.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\_pytest\runner.py:246: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
.venv\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\runner.py:164: in pytest_runtest_setup
    item.session._setupstate.setup(item)
.venv\Lib\site-packages\_pytest\runner.py:514: in setup
    col.setup()
.venv\Lib\site-packages\_pytest\python.py:1674: in setup
    self._request._fillfixtures()
.venv\Lib\site-packages\_pytest\fixtures.py:719: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:548: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:639: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv\Lib\site-packages\_pytest\fixtures.py:1127: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:1195: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\fixtures.py:922: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:264: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:251: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
.venv\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
.venv\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/samqu/AppData/Local/Temp/pytest-of-samqu')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\samqu\\AppData\\Local\\Temp\\pytest-of-samqu'

.venv\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
================================== FAILURES ===================================
____________ TestSecurityManager.test_init_with_service_principal _____________

self = <MagicMock name='ClientSecretCredential' id='2682763753664'>, args = ()
kwargs = {'client_id': 'test-client-id', 'client_secret': 'test-secret', 'tenant_id': 'test-tenant'}
msg = "Expected 'ClientSecretCredential' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'ClientSecretCredential' to be called once. Called 0 times.

C:\ProgramData\miniconda3\Lib\unittest\mock.py:990: AssertionError

During handling of the above exception, another exception occurred:

self = <test_security_manager.TestSecurityManager object at 0x00000270A1133230>
mock_credential = <MagicMock name='ClientSecretCredential' id='2682763753664'>
mock_client = <MagicMock name='SecretClient' id='2682763752992'>

    @patch('src.security_manager.SecretClient')
    @patch('src.security_manager.ClientSecretCredential')
    def test_init_with_service_principal(self, mock_credential, mock_client):
        """Test initialization with service principal credentials."""
        with patch.dict(os.environ, {
            'AZURE_CLIENT_ID': 'test-client-id',
            'AZURE_CLIENT_SECRET': 'test-secret',
            'AZURE_TENANT_ID': 'test-tenant'
        }):
            mock_client_instance = Mock()
            mock_client_instance.list_properties_of_secrets.return_value = iter([])
            mock_client.return_value = mock_client_instance
    
            manager = SecurityManager(keyvault_url="https://test.vault.azure.net/")
    
>           mock_credential.assert_called_once_with(
                tenant_id='test-tenant',
                client_id='test-client-id',
                client_secret='test-secret'
            )
E           AssertionError: Expected 'ClientSecretCredential' to be called once. Called 0 times.

src\tests\test_security_manager.py:42: AssertionError
____________ TestSecurityManager.test_init_with_default_credential ____________

self = <MagicMock name='DefaultAzureCredential' id='2682763754000'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'DefaultAzureCredential' to have been called once. Called 0 times.

C:\ProgramData\miniconda3\Lib\unittest\mock.py:958: AssertionError

During handling of the above exception, another exception occurred:

self = <test_security_manager.TestSecurityManager object at 0x00000270A1133360>
mock_credential = <MagicMock name='DefaultAzureCredential' id='2682763754000'>
mock_client = <MagicMock name='SecretClient' id='2682763754336'>

    @patch('src.security_manager.SecretClient')
    @patch('src.security_manager.DefaultAzureCredential')
    def test_init_with_default_credential(self, mock_credential, mock_client):
        """Test initialization with default credential chain."""
        with patch.dict(os.environ, {}, clear=True):
            mock_client_instance = Mock()
            mock_client_instance.list_properties_of_secrets.return_value = iter([])
            mock_client.return_value = mock_client_instance
    
            manager = SecurityManager(keyvault_url="https://test.vault.azure.net/")
    
>           mock_credential.assert_called_once()
E           AssertionError: Expected 'DefaultAzureCredential' to have been called once. Called 0 times.

src\tests\test_security_manager.py:60: AssertionError
_______________________________ test_import_05 ________________________________

    def test_import_05():
>       __import__("hallandale_pipeline_fixed")

universal_recon\tests\auto_smoke\test_auto_05.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\hallandale_pipeline_fixed.py:22: in <module>
    class HallandalePipeline:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    class HallandalePipeline:
        """Complete Hallandale property processing pipeline."""
    
        def __init__(self, output_dir: str = "outputs/hallandale"):
            self.output_dir = Path(output_dir)
            self.output_dir.mkdir(parents=True, exist_ok=True)
    
            # Create logs directory
            (self.output_dir / "logs").mkdir(exist_ok=True)
    
            # Setup logging
            self._setup_logging()
    
            # Initialize processors
            self.pdf_processor = HallandalePropertyProcessor(output_dir)
            self.enricher = PropertyEnrichment(output_dir)
            self.validator = PropertyValidation(output_dir)
    
            self.logger.info("Hallandale Pipeline initialized")
    
        def _setup_logging(self) -> None:
            """Setup comprehensive logging."""
            log_file = self.output_dir / "logs" / "pipeline.log"
    
            logging.basicConfig(
                level=logging.INFO,
                format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                handlers=[logging.FileHandler(log_file), logging.StreamHandler()],
            )
    
            self.logger = logging.getLogger(__name__)
            self.logger.info("STARTING HALLANDALE PROPERTY PROCESSING PIPELINE")
            self.logger.info("=" * 60)
    
>       def run_pipeline(self, pdf_path: str) -> Dict[str, Any]:
                                                 ^^^^
E       NameError: name 'Dict' is not defined

src\hallandale_pipeline_fixed.py:56: NameError
_______________________________ test_import_09 ________________________________

    def test_import_09():
>       __import__("orchestrator")

universal_recon\tests\auto_smoke\test_auto_09.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    #!/usr/bin/env python3
    """
    Unified Scraper Orchestrator
    Main controller that coordinates all scraping operations using the modular framework.
    """
    
    import os
    import time
    from datetime import datetime
    from pathlib import Path
    from typing import Any, Dict, List, Optional, Union
    
    import pandas as pd
    
>   from .config_loader import ConfigLoader
E   ImportError: attempted relative import with no known parent package

src\orchestrator.py:15: ImportError
___________________________ test_firm_plugin_loads ____________________________

    def test_firm_plugin_loads():
        m = importlib.import_module('universal_recon.plugins.firm_parser')
>       assert hasattr(m, 'FirmParserPlugin')
E       AssertionError: assert False
E        +  where False = hasattr(<module 'universal_recon.plugins.firm_parser' from 'C:\\Code\\bar-directory-recon\\universal_recon\\plugins\\firm_parser.py'>, 'FirmParserPlugin')

universal_recon\tests\plugins\test_firm_plugin.py:6: AssertionError
_______________________ test_firm_plugin_contract_smoke _______________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x00000270A1413A80>

    def test_firm_plugin_contract_smoke(monkeypatch):
        m = importlib.import_module('universal_recon.plugins.firm_parser')
>       P = m.FirmParserPlugin()
            ^^^^^^^^^^^^^^^^^^
E       AttributeError: module 'universal_recon.plugins.firm_parser' has no attribute 'FirmParserPlugin'

universal_recon\tests\plugins\test_firm_plugin.py:11: AttributeError
============================== warnings summary ===============================
universal_recon\tests\analytics\test_plugin_usage_diff.py:14
  C:\Code\bar-directory-recon\universal_recon\tests\analytics\test_plugin_usage_diff.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.analytics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.analytics

universal_recon\tests\analytics\test_risk_overlay_emitter.py:18
  C:\Code\bar-directory-recon\universal_recon\tests\analytics\test_risk_overlay_emitter.py:18: PytestUnknownMarkWarning: Unknown pytest.mark.analytics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.analytics

test_data_hunter.py::test_discovery
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_data_hunter.py::test_discovery returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_imports
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_imports returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_basic_functionality
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_basic_functionality returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_framework.py::test_config_validation
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_framework.py::test_config_validation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_google_sheets.py::test_cli_arguments
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_google_sheets.py::test_cli_arguments returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_google_sheets.py::test_logs_directory
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_google_sheets.py::test_logs_directory returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_plugin_architecture.py::test_plugin_architecture
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_plugin_architecture.py::test_plugin_architecture returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_plugin_architecture_fixed.py::test_plugin_architecture
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_plugin_architecture_fixed.py::test_plugin_architecture returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_plugin_registry
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_plugin_registry returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_new_plugins
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_new_plugins returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_universal_automation
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_universal_automation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_lead_scoring
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_lead_scoring returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_google_sheets_utils
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_google_sheets_utils returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_system.py::test_file_structure
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_system.py::test_file_structure returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

.venv\Lib\site-packages\_pytest\cacheprovider.py:475
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\cacheprovider.py:475: PytestCacheWarning: could not create cache path C:\Code\bar-directory-recon\.pytest_cache\v\cache\nodeids: [WinError 5] Access is denied: 'C:\\Code\\bar-directory-recon\\.pytest_cache\\v\\cache'
    config.cache.set("cache/nodeids", sorted(self.cached_nodeids))

.venv\Lib\site-packages\_pytest\cacheprovider.py:429
  C:\Code\bar-directory-recon\.venv\Lib\site-packages\_pytest\cacheprovider.py:429: PytestCacheWarning: could not create cache path C:\Code\bar-directory-recon\.pytest_cache\v\cache\lastfailed: [WinError 5] Access is denied: 'C:\\Code\\bar-directory-recon\\.pytest_cache\\v\\cache'
    config.cache.set("cache/lastfailed", self.lastfailed)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
- generated xml file: C:\Code\bar-directory-recon\logs\nightly\junit_after_fix2.xml -
=========================== short test summary info ===========================
FAILED src/tests/test_security_manager.py::TestSecurityManager::test_init_with_service_principal
FAILED src/tests/test_security_manager.py::TestSecurityManager::test_init_with_default_credential
FAILED universal_recon/tests/auto_smoke/test_auto_05.py::test_import_05 - Nam...
FAILED universal_recon/tests/auto_smoke/test_auto_09.py::test_import_09 - Imp...
FAILED universal_recon/tests/plugins/test_firm_plugin.py::test_firm_plugin_loads
FAILED universal_recon/tests/plugins/test_firm_plugin.py::test_firm_plugin_contract_smoke
ERROR src/tests/test_hallandale_pipeline.py::test_pipeline_nonexistent_pdf - ...
ERROR src/tests/test_hallandale_pipeline_success.py::test_pipeline_success - ...
ERROR universal_recon/tests/test_risk_overlay_emitter.py::test_emit_site_risk_json
ERROR universal_recon/tests/test_risk_overlay_emitter.py::test_load_validator_tiers
6 failed, 87 passed, 3 skipped, 5 deselected, 18 warnings, 4 errors in 48.10s
